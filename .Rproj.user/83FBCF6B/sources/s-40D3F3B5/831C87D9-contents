---
title: "Introduction to R and RStudio"
author: "Emily C. Zabor"
date: "May 13, 2021"
output:
  html_document:
    theme: flatly
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# About me

```{r echo = FALSE, out.width = "25%", fig.cap = "MS in Biostatistics from the University of Minnesota"}
knitr::include_graphics(here::here("img", "UMN.jpg"))
```

<br>

```{r echo = FALSE, out.width = "25%", fig.cap = "DrPH in Biostatistics from Columbia University"}
knitr::include_graphics(here::here("img", "CU.jpg"))
```

<br>

```{r echo = FALSE, out.width = "50%", fig.cap = "10 years as a Research Biostatistician at Memorial Sloan Kettering Cancer Center"}
knitr::include_graphics(here::here("img", "msk-black-logo.png"))
```

<br>

```{r echo = FALSE, out.width = "50%", fig.cap = "Assistant Staff in Quantitative Health Sciences & Taussig Cancer Institute since 2019"}
knitr::include_graphics(here::here("img", "Taussig.jpg"))
```

<br>

# About you

Please make sure you have your first and last name listed on Zoom. 

(Click on the "Participants" button, hover your mouse over your name until you see some options displayed, click "Rename" and type your first and last name)

Introduce yourselves by saying your name and how you envision using R and RStudio as part of your education and research.

<br>


# Introduction to R

```{r echo = FALSE, out.width = "25%"}
knitr::include_graphics(here::here("img", "Rlogo.png"))
```

R is a free, open-source software environment for statistical computing and graphics maintained by an international team of developers.

Because R is free, many of the functions you may wish to use will be contributed by other users as packages and available through repositories such as CRAN, GitHub, or Bioconductor, among others. It is your responsibility to vet the quality and accuracy of any user-contributed packages. The functions available with the initial installation of R, known as base R, can be considered trustworthy.

## Installing R

Go to the website for [The Comprehensive R Archive Network](https://cran.r-project.org/). The top of the web page provides three links for downloading R. Follow the link that describes your operating system: Windows, Mac, or Linux.

We will focus on installation for Windows and Mac. If you use any of Linux servers available at Cleveland Clinic, R should already be installed or you can work with the appropriate IT department to install R or any needed packages.

### Windows

To install R on Windows, click the “Download R for Windows” link. Then click the “base” link. Next, click the first link at the top of the new page. This link should say something like “Download R 4.0.5 for Windows,” except the 4.0.5 will be replaced by the most current version of R. The link downloads an installer program, which installs the most up-to-date version of R for Windows. Run this program and step through the installation wizard that appears. The wizard will install R into your program files folders and place a shortcut in your Start menu. 

### Mac

To install R on a Mac, click the “Download R for (Mac) OS X” link. Next, click on the "R-4.0.5.pkg" package link. The 4.0.5 will be replaced by the most current version of R. An installer will download to guide you through the installation process. The installer lets you customize your installation, but the defaults will be suitable for most users. 

## Open R and take a look

The R Graphical User Interface (Gui) will contain a window labeled R Console. You can type code directly into the console and get results.

The main issue is that while you can save the R session, you cannot save the raw source code. 

Let's test some basic code:

```{r eval = FALSE}
x <- c(1, 2, 3, 4)
mean(x)
hist(rnorm(100))
```

<br>


# Introduction to RStudio

```{r echo = FALSE, out.width = "25%"}
knitr::include_graphics(here::here("img", "RStudio-Logo-Flat.png"))
```

RStudio is an Integrated Development Environment (IDE) that runs R, and allows users to develop and edit programs and offers higher quality graphics and a more user-friendly interface.

## Installing RStudio

Go to the website for [RStudio](https://www.rstudio.com/products/rstudio/) and select "RStudio Desktop". Then click the button for "Download RStudio Desktop". Select the Free version to download. An installer will download and provide simple instructions to follow.

## Open RStudio and take a look

When you first open RStudio you will see a number of panes, including the console, which works exactly the same way as the R Console in R itself. We will always want to use a text editor to type our code before running so that we can save our code for reproducibility purposes.

## RStudio basics

Let's open an R text editor window and then try some basic code.

Go to File > New File > R script

Then go to File > Save and save this somewhere convenient for you with your other class materials with the filename "mmed501-r-session1.R"

Now let's type the following code into our newly created file:

```{r eval = FALSE}
x <- c(1, 2, 3, 4)
mean(x)
hist(rnorm(100))
```

To send this to the console to be executed, you can do one of the following:

1. Place your cursor next to the line you want to run and hit Ctrl+Enter on your keyboard
2. Place your cursor next to the line you want to run and hit the "Run" button
3. Highlight all three lines of code and use one of the previous options

After we have run all three lines of code, we see the results of our mean computation in the Console pane. And we see the resulting histogram in the Plots pane.

But how would we get these results out of RStudio to turn in for homework or share with collaborators? This is where RMarkdown comes in handy.

<br>


# R Markdown (very briefly)

One of the benefits of RStudio is seamless integration of R Markdown.

Go to File > New File > R Markdown...

You will see options to create a Document, Presentation, Shiny, or From Template. The most common choice is to create a Document. Let's type "MMED501 R session 1" in the Title box and type your name in the Author box. Select the radio button for HTML under "Default Output Format" and click OK. 

A new file will open with .Rmd as the file extension. Go to File > Save and save this in the same location as the previous .R file we saved, with the filename "mmed501-rmd-session1.Rmd"

The top part of the file, between the two sets of ---, is called the yaml header. There are many options you can set here to format your document in specific ways, but it provides sensible and basic defaults. The important thing to know about the yaml is that spacing and returns are very important and a common source of error.

Next you'll see that the document has come pre-filled with some default information to get you started. The first thing you see starting with ```{r ...} is called a code chunk. This is where you will type the R code that you want to be executed. Below that you will see some text that will be printed to the resulting file. Text is based on markdown, so you can use any markdown formatting options for headers, bold, italic, etc.

Let's delete out the default text, leaving the top R chunk. This R chunk is telling R that we want our actual code to print to the file as well. To suppress code and only show the results of code, you can change this from `knitr::opts_chunk$set(echo = TRUE)` to `knitr::opts_chunk$set(echo = FALSE)`.

Now return two lines and go to Insert > R to insert a new R code chunk. Copy and paste our three lines of code there:

```{r eval = FALSE}
x <- c(1, 2, 3, 4)
mean(x)
hist(rnorm(100))
```

Return two more lines and type some text that you want to print.

You can also execute R code inline instead of in an R chunk by using `` `r knitr::inline_expr("expression")` ``, where expression is replaced by the code you want to evaluate.

Now, to generate the output, we can simply hit "Knit". A new window will pop up with the html output of your program. In this way you can create reproducible reports for all of your projects.

Read more here: [https://bookdown.org/yihui/rmarkdown/](https://bookdown.org/yihui/rmarkdown/)

<br>


# Loading data

The most common data format we work with are data from Excel. Let's explore a dataset that comes in the "gtsummary" package in R, called `trial`.

First, we install and load the "gtsummary" package:

```{r eval = FALSE}
install.packages("gtsummary")
```

```{r}
library(gtsummary)
```

We can preview the `trial` data by simply typing the name of the dataset:

```{r}
trial
```

We can explore the contents of `trial` by running

```{r eval = FALSE}
?trial
```

(Note that if you place a question mark in front of the name of any R function, it will take you to the help page for that function)

```{r echo = FALSE, eval = FALSE}
# write the trial data to Excel
# Interestingly, write.xlsx with row.names = FALSE doesn't seem to work for tbl_df class, so I had to make some changes to the data
trial2 <- trial
attributes(trial2)$class <- c("data.frame")
xlsx::write.xlsx(x = trial2, 
                 file = here::here("trial-Excel.xlsx"), 
                 row.names = FALSE)
```

I have saved this data file out to Excel so that we can practice loading it in R.

Go to the [course website](https://mylearning.ccf.org/course/view.php?id=8435) to download the file. Save it to the same location where you previously saved your "mmed501-r-session1.R" and "mmed501-rmd-session1.Rmd" files.

<br>

## Reading in Excel files

Use your R file "mmed501-r-session1.R" to practice the following code to read in files.

Two approaches:

1. Use the "readxl" package. 

    First install the package from CRAN using `install.packages()`
    

    ```{r eval = FALSE}
    install.packages("readxl")
    ```

    Then load the newly installed package with a call to `library()`
  
    ```{r}
    library(readxl)
    ```
  
    And finally use the `read_excel()` function with the appropriate file path to read in the data and save it as an object called "mydf"
  
    ```{r}
    mydf <- read_excel("H:/MMED501/2021/MMED501-R-Session1/trial-Excel.xlsx")
    ```
    
    Notes:
    
    - R treats the \\ as a special character so you either need to use / or \\\ in file paths)
    
2. Save the file as .csv and read in with base R

    Advantages: removes some of the possible formatting pitfalls associated with Excel files, and you don't need any special packages to read this format.

    First, open the Excel file.
    
    Go to File > Save As and select "CSV (Comma delimited)" from the "Save as type" drop down.
    
    Then use the `read.csv()` function with the appropriate file path to read in the data and save it as an object called "mydf2"
    
    ```{r}
    mydf2 <- read.csv("H:/MMED501/2021/MMED501-R-Session1/trial-csv.csv")
    ```
    
<br>


# Plotting in R

Plotting features are available in base R or through a package. A very popular package for plotting in R is the "ggplot2" package. Since I do all of my plotting using "ggplot2" I will focus on this for plotting in this course, but will try to also show corresponding base R plotting code in case you prefer to use that approach. 

First install and load the ggplot2 package:

```{r eval = FALSE}
install.packages("ggplot2")
```

```{r}
library(ggplot2)
```


## Histograms 

It is common to want to describe a continuous variable using a histogram, particularly to examine whether the distribution appears approximately normal.

Let's examine the variable "mpg" in the dataset we created called "mydf". 

Using the "ggplot2" package, we build our plots by first specifying the dataset and the basic aesthetics in a call to the `ggplot()` function, and we then add layers to the plot with "+" signs. So to create a basic histogram we start by specifying the data and saying we want to see the variable marker on the x-axis, and then we add a layer for `geom_histogram()`:

```{r}
ggplot(data = mydf, aes(x = marker)) + 
  geom_histogram()
```

We see that the default number of bins is too many for this  dataset (and we do get a warning telling us to "Pick better value"), so let's also specify a smaller number of bins for the histogram using the `bins` argument to `geom_histogram()`:

```{r}
ggplot(data = mydf, aes(x = marker)) + 
  geom_histogram(bins = 10)
```

The other warning we get is simply telling us that there are missing values in the variable marker, which we will ignore for now.

We can use the `hist()` function in base R to create a histogram:

```{r}
hist(mydf$marker)
```

Note here that we use `datasetname$variablename` to specify a specific variable from a specific dataset. This is common syntax in base R that you should get used to using in many cases.

From both plots, we see that we have a positively skewed distribution for the variable "marker" from the `trial` data. 

What if we wanted to see the distribution of marker according to disease grade?

By adding a layer to our `ggplot()` using `facet_grid()`, we now have panels in our plot for each level of the disease grade variable "grade". Note that by default the y-axis and x-axis limits are fixed across all plots, so we can directly compare the distributions. It is possible to control this with the `scales` argument to `facet_grid()`, see `?facet_grid` for details. We are telling it that we want the variable "grade" to be used as column-wise panels.

```{r}
ggplot(data = mydf, aes(x = marker)) + 
  geom_histogram(bins = 10) +
  facet_grid(cols = vars(grade))
```

This is a bit more cumbersome to do in base R plotting, and you'll see that this plot would need a lot of customization to be labelled more appropriately. Note in particular that by default the y-axis and x-axis limits are different in each panel, so the plots are not directly comparable.

```{r}
par(mfrow = c(1, 3))
hist(mydf$marker[mydf$grade == "I"])
hist(mydf$marker[mydf$grade == "II"])
hist(mydf$marker[mydf$grade == "III"])
```


## Boxplots

Boxplots are another common way of examining continuous variables. We want the continuous variable on the y-axis instead of the x-axis as in the histogram case, and now we add the layer for `geom_boxplot()`:

```{r}
ggplot(data = mydf, aes(y = marker)) + 
  geom_boxplot()
```

In base R:

```{r}
boxplot(mydf$marker)
```

Now let's again see the boxplot for marker according to disease grade.

```{r}
ggplot(data = mydf, aes(y = marker)) + 
  geom_boxplot() + 
  facet_grid(cols = vars(grade))
```

In base R:

```{r}
par(mfrow = c(1, 3))
boxplot(mydf$marker[mydf$grade == "I"])
boxplot(mydf$marker[mydf$grade == "II"])
boxplot(mydf$marker[mydf$grade == "III"])
```


## Scatterplots

Sometimes we will want to examine two continuous variables together on a plot. For example, what if we wanted to see a plot of "marker" by "age". Let's put age on the x-axis and marker on the y-axis and then we can add a layer for `geom_point()` to produce a scatterplot:

```{r}
ggplot(data = mydf, aes(x = age, y = marker)) + 
  geom_point()
```

In base R:

```{r}
plot(mydf$age, mydf$marker)
```


## Exporting plots

We will often want to save plots to an external file to insert into a later document. There are several options for doing so.

1. Use the interactive plot window to export your created plot.

    A. Create your plot:

    ```{r eval = FALSE}
    ggplot(data = mydf, aes(x = marker)) + 
      geom_histogram(bins = 10) +
      facet_grid(cols = vars(grade))
    ```
    
    B. Click on "Export" then select the option "Copy to Clipboard". This will open a pop-up window where you could rescale the plot, if desired, and then click "Copy Plot" to copy the plot to your clipboard so that you can paste it into an external document. So if I open Word document, for example, I can simply paste the plot in.
    
    C. Click on "Export" then select the option "Save as Image...". Here you can change the directory location where you want to save the plot to the same location where you have your code and data files for this class saved so far. You can select from a variety of file formats. Save it as "my-histogram" in PNG format. You can then insert this file into other documents as needed.
    
    D. Click on "Export" then select the option "Save as PDF..." and follow the same instructions as in B to save a .pdf version of your image.
    
2. Use code to save your plot to an external location. There is a function called `ggsave()` specifically for saving results of `ggplot()`. By default it will save the last created plot, or you can save your plot to an object and specify it directly using the `plot` argument to `ggsave()`. You will specify the file format by including an extension, here ".png" on your filename.

    ```{r}
    p <- ggplot(data = mydf, aes(y = marker)) + 
      geom_boxplot() + 
      facet_grid(cols = vars(grade))
    
    ggsave(filename = "H:/MMED501/2021/MMED501-R-Session1/my-boxplot.png", 
           plot = p)
    ```
    
    You will see that in the Console window the default width and height of the resulting plot were printed, and these can both be changed by using the `width` and/or `height` arguments to the `ggsave()` function.
    
    In base R, we wrap our plot code in first a call to `png()` (or jpeg() or pdf() etc) with the filename specified and at the end a call to `dev.off()`:
    
    ```{r}
    png("H:/MMED501/2021/MMED501-R-Session1/my-boxplot-base.png")
    par(mfrow = c(1, 3))
    boxplot(mydf$marker[mydf$grade == "I"])
    boxplot(mydf$marker[mydf$grade == "II"])
    boxplot(mydf$marker[mydf$grade == "III"])
    dev.off()
    ```

<br>


# Descriptive statistics in R

In addition to plotting, we will often want to describe our data using summary statistics such as number and percentage for categorical variables and median and interquartile range for continuous variables.

## Summarizing continuous variables

Functions to summarize continuous variables:

- `summary()`: calculates the minimum, 1st quartile, median, mean, 3rd quartile, and maximum as well as the number of missing values. 
- `mean()`: calculates the mean
- `sd()`: calculates the standard deviation
- `median()`: calculates the median
- `min()`: calculates the minimum
- `max()`: calculates the maximum
- `quantile()`: calculates specified quantiles

Note that in the presence of missing data, most of these functions will require the use of the `na.rm = TRUE` argument, which simply ignores any missing values in the calculation. If not specified and missing values are present, the function will return NA.

```{r}
summary(trial$marker)
mean(trial$marker, na.rm = TRUE)
sd(trial$marker, na.rm = TRUE)
median(trial$marker, na.rm = TRUE)
min(trial$marker, na.rm = TRUE)
max(trial$marker, na.rm = TRUE)
quantile(trial$marker, probs = c(0.25, 0.75), na.rm = TRUE)
```

Note that we specified the argument `probs = c(0.25, 0.75)` to the `quantile()` function to specify that we wanted the 1st (i.e. 25%) and 3rd (i.e. 75%) quantiles.

We can get summaries of continuous variables by a categorical variable using the function `tapply()` in the following ways, for example to summarize "marker" by levels of "grade":

```{r}
tapply(trial$marker, trial$grade, summary)
tapply(trial$marker, trial$grade, mean, na.rm = TRUE)
tapply(trial$marker, trial$grade, quantile, probs = c(0.25, 0.75), na.rm = TRUE)
```


## Summarizing categorical variables

Functions to summarize categorical variables:

- `table()`: calculates the number in each group 
- `prop.table()`: calculates the proportion in each group

Note that the argument `useNA = "ifany"` needs to be specified in `table()` in order to see the number of any missing values. If not specified, missing values will be ignored.

```{r}
table(trial$response, useNA = "ifany")
prop.table(table(trial$response))
```

And we can easily generate cross-tabulations of two categorical variables by simply passing a second variable to `table()`. For example if we wanted a table of "response" according to "grade":

```{r}
table(trial$grade, trial$response, useNA = "ifany")
prop.table(table(trial$grade, trial$response))
```


## Summarizing many variables

What we often need to do in our area of work is what we call a "Table 1" where we describe many characteristics of a study population either overall, or according to another variable. I like to do this in R using the "gtsummary" package.

We installed and loaded this package earlier in order to access the "trial" dataset to use as an example, but as a reminder:

```{r eval = FALSE}
install.packages("gtsummary")
library(gtsummary)
```

We can make overall tables using the `tbl_summary()` function. First we will limit the variables in the data to a few of interest:

```{r}
trial2 <- trial[, c("age", "marker", "stage", "grade", "trt")]

tbl_summary(trial2)
```

We see that by default this provides the median (IQR) for continuous variables and n (%) for categorical variables, as noted in the footnote. The summary statistics can be customized in many wasy so see `?tbl_summary` for options or checkout [this tutorial](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html) for more details.

We can also easily create tables of summary statistics according to another variable by specifying the `by` argument to the `tbl_summary()` function:

```{r}
tbl_summary(
  trial2, 
  by = "trt"
)
```

Note that the functions from the "gtsummary" package are particularly useful when used in conjunction with R Markdown, since they are meant to produce publication-ready tables.









